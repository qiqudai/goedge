worker_processes  auto; # Auto detect cores
worker_rlimit_nofile 65535; # High concurrency file descriptors

events {
    worker_connections  10240; # High concurrency per worker
    use epoll;
    multi_accept on;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    
    # --------------------------------------------------------
    # 1. Performance Tuning (Kernel/Network)
    # --------------------------------------------------------
    sendfile        on;
    tcp_nopush      on;
    tcp_nodelay     on;
    keepalive_timeout  65;
    keepalive_requests 10000;
    
    # --------------------------------------------------------
    # 2. JSON Logging (User Req #2) - Machine Parsable
    # --------------------------------------------------------
    log_format json_analytics escape=json
    '{'
      '"time_iso8601": "$time_iso8601",'
      '"remote_addr": "$remote_addr",'
      '"host": "$host",'
      '"request": "$request",'
      '"status": $status,'
      '"body_bytes_sent": $body_bytes_sent,'
      '"request_time": $request_time,'
      '"upstream_addr": "$upstream_addr",'
      '"upstream_response_time": "$upstream_response_time",'
      '"upstream_cache_status": "$upstream_cache_status",'
      '"http_referer": "$http_referer",'
      '"http_user_agent": "$http_user_agent",'
      '"scheme": "$scheme",'
      '"ssl_protocol": "$ssl_protocol",'
      '"ssl_cipher": "$ssl_cipher"'
    '}';

    access_log logs/access.json json_analytics;
    error_log  logs/error.log warn;

    # --------------------------------------------------------
    # 3. Native Security Layers (User Req #4 - "C Layer")
    # --------------------------------------------------------
    
    # Limit Request Zone (High Frequency CC)
    # zone=cc_limit:10m (store ~160k IPs) rate=50r/s (standard baseline)
    limit_req_zone $binary_remote_addr zone=cc_limit:10m rate=50r/s;

    # Limit Connection Zone (L7 concurrent connections)
    limit_conn_zone $binary_remote_addr zone=addr_conn:10m;
    
    # --------------------------------------------------------
    # 4. Caching Base Configuration (User Req #3)
    # --------------------------------------------------------
    # path: /data/cache levels: 1:2 keys_zone: 50m inactive: 24h
    # Note: User must create this directory or update path
    proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:50m max_size=10g inactive=24h use_temp_path=off;
    
    # Shared Dictionaries for Lua (Metrics & Config)
    lua_shared_dict metrics_store 20m;
    lua_shared_dict config_store 10m;
    lua_shared_dict waf_cache 10m;
    lua_shared_dict ip_blacklist 10m;
    lua_shared_dict limit_req_store 20m;
    
    # Init Worker: Metrics & Config
    init_worker_by_lua_block {
        local config_loader = require "lua.config_loader"
        config_loader.init() 
    }

    server {
        listen       80;
        server_name  localhost;
        
        # ----------------------------------------------------
        # 5. Core Proxy Logic
        # ----------------------------------------------------
        location / {
            # --- A. Native Protections ---
            limit_req zone=cc_limit burst=20 nodelay;
            limit_conn addr_conn 50;

            # --- B. Lua Dynamic Hooks (Routing/WAF) ---
            access_by_lua_file lua/access.lua;
            
            # --- C. Caching ---
            proxy_cache my_cache;
            proxy_cache_key $host$uri$is_args$args;
            proxy_cache_valid 200 302 10m;
            proxy_cache_valid 404 1m;
            
            # Critical: Cache Breakdown Protection (User Req #3)
            proxy_cache_lock on;
            proxy_cache_lock_timeout 5s;
            proxy_cache_lock_age 5s;
            
            # Critical: Origin Down Protection (User Req #3)
            proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
            proxy_cache_background_update on;
            
            # --- D. Proxy ---
            # Placeholder upstream, will typically use variables set in access_by_lua
            set $backend_target "http://127.0.0.1:8080"; 
            proxy_pass $backend_target;
            
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            
            # --- E. Metrics Hooks ---
            log_by_lua_block {
                local metrics = require "lua.metrics"
                metrics.log_request(ngx.var.host, ngx.var.status, ngx.var.body_bytes_sent, ngx.var.upstream_response_time)
            }
        }
        
        # ----------------------------------------------------
        # 6. Observability Endpoints
        # ----------------------------------------------------
        location /metrics {
            # Restrict access in production!
            allow 127.0.0.1;
            deny all;
            
            content_by_lua_block {
                local metrics = require "lua.metrics"
                ngx.say(metrics.get_prometheus_data())
            }
        }
        
        location /stub_status {
            stub_status;
            allow 127.0.0.1;
            deny all;
        }
    }

    # --------------------------------------------------------
    # 7. HTTPS Server (User Req #5)
    # --------------------------------------------------------
    server {
        listen       443 ssl;
        server_name  _; # Dynamic SNI
        
        # Modern TLS Security
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers on;
        
        # Hardcoded fallback certs (Must exist for Nginx to start)
        # User should generate these: openssl req -new -newkey rsa:2048 -days 3650 -nodes -x509 -keyout conf/cert/fallback.key -out conf/cert/fallback.pem
        ssl_certificate      cert/fallback.pem; 
        ssl_certificate_key  cert/fallback.key;
        
        # Dynamic Certificate Loading Hook
        ssl_certificate_by_lua_block {
            local ssl_mgr = require "lua.ssl_manager"
            ssl_mgr.set_certificate()
        }

        # Reuse same logic as HTTP
        location / {
            # --- A. Native Protections ---
            limit_req zone=cc_limit burst=20 nodelay;
            limit_conn addr_conn 50;

            # --- C. Caching ---
            proxy_cache my_cache;
            proxy_cache_key $host$uri$is_args$args;
            proxy_cache_valid 200 302 10m;
            proxy_cache_valid 404 1m;
            
            proxy_cache_lock on;
            proxy_cache_lock_timeout 5s;
            proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
            proxy_cache_background_update on;
            
            # --- D. Dynamic Proxy ---
            set $backend_target "http://127.0.0.1:8080"; 
            # Note: variable set by access.lua, but we need to run it!
            access_by_lua_file lua/access.lua;
            
            proxy_pass $backend_target;
            
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            
            # --- E. Metrics Hooks ---
            log_by_lua_block {
                -- local metrics = require "lua.metrics"
                -- metrics.log_request(ngx.var.host, ngx.var.status, ngx.var.body_bytes_sent, ngx.var.upstream_response_time)
                -- Enabling now:
                local metrics = require "lua.metrics"
                metrics.log_request(ngx.var.host, ngx.var.status, ngx.var.body_bytes_sent, ngx.var.upstream_response_time)
            }
        }
    }
